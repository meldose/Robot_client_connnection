# # This file has been generated by neura_program_generator version 0.0.1 on 2024-12-19 10:09:43.065282
# # Program name in GUI: Program_002

# from time import sleep
# import signal
# import sys
# import threading

# import socketio

# from neurapy.state_flag import cmd
# from neurapy.component import Component
# from neura_apps.gui_program.program import Program
# from neurapy.robot import Robot
# from neurapy.commands.state.robot_status import RobotStatus
# from neurapy.loop_counter import loopCount
# from neurapy.utils import CmdIDManager
# from neurapy.socket_client import _SocketClient, get_sio_client_singleton_instance

# from move_camera.servo import ServoApp

# # Global constants
# STEP_SLEEP_INTERVAL = 0.01

# # Global variables
# cur_step: int = 0
# is_new_step: bool = False


# def main(robot_handler):
# 	# --------------------------  CREATING Robot & Program & RobotStatus OBJECTS  -----------------------

# 	program_handler = Program(robot_handler)
# 	robot_status = RobotStatus(robot_handler)
# 	iterator = loopCount()
# 	tool_objects = {}
# 	blackboard = {}

# 	robot_handler.notify_info("Starting execution of program 'Program_002'")

# 	sio_object: _SocketClient = register_sio_callbacks(program_handler)

# 	# Set initial value of dynamic id higher than the highest fixed cmd_id, so it does not intervene
# 	id_manager = CmdIDManager(3)

# 	# Initializing local tools for Program 'Program_002'
# 	tool_objects['NoTool'] = robot_handler.gripper(gripper_name = 'STANDARD_GRIPPER',tool_name = 'NoTool')
# 	# Setting tool 'NoTool' for Program 'Program_002'
# 	try:
# 		current_tool = 'NoTool'
# 		current_tool_params = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
# 		robot_handler.set_tool(tool_name = current_tool, tool_params = current_tool_params)
# 	except Exception as e:
# 		program_handler._Program__PS.socket_object.send_gui_message(f'Error {current_tool} tool not set properly: {str(e)}','Error')
# 		raise e

# 	ms_001 = ServoApp(robot_handler, servo_type='Static', program_name='Program_002', app_name='ms_001',  cmd_id=2)

# 	# -------------------------------  INITIAL JOINT STATE & CARTESIAN POSE  ----------------------------

# 	previous_joint_angles = robot_status.getRobotStatus('jointAngles')
# 	previous_cartesian_poses = robot_handler.ik_fk("fk", target_angle = previous_joint_angles, tool_params = current_tool_params)

# 	motion_data = {
# 		"speed": 50.0,
# 		"acceleration": 50.0,
# 		"target_joint": [
# 			previous_joint_angles,
# 			previous_joint_angles
# 		]
# 	}
# 	# Planning mj to first point | static planning
# 	program_handler.set_command(cmd.Joint, **motion_data, cmd_id = 1, current_joint_angles = previous_joint_angles, reusable_id = 0)
# 	program_handler.execute([1])
# 	#sio_object.send_gui_message({"state": "FINISHED"}, socket_name="StepByStep")
# 	# --------------------------------------  PLANNING COMMANDS  ----------------------------------------


# 	blackboard = {}
# 	# --------------------------------------  EXECUTING COMMANDS  ---------------------------------------

# 	# Executing ms_001
# 	block_until_next_step(robot_handler)
# 	ms_001.execute()
# 	sio_object.send_gui_message({'state': 'FINISHED'}, socket_name='StepByStep')


# def register_sio_callbacks(program_handler: Program) -> _SocketClient:
# 	sio_handler = get_sio_client_singleton_instance()
# 	sio_register = sio_handler.get_sio_client_register_obj()
# 	sio_register.on("StepByStep", handle_sio_step_by_step)
# 	sio_obj_client = sio_handler.get_sio_client_obj()
# 	return sio_obj_client

# def handle_sio_step_by_step(data: dict):
# 	global cur_step
# 	global is_new_step
# 	print(f"handling socket message on channel 'StepByStep' with data {data}")
# 	old_step = cur_step
# 	cur_step = int(data.get('id', -1))
# 	if(old_step != cur_step):
# 		is_new_step = True

# def read_cur_step_from_gui() -> int:
# 	global cur_step
# 	return cur_step

# def block_until_next_step(robot: Robot):
# 	global cur_step
# 	global is_new_step
# 	old_step = cur_step
# 	while(robot.is_robot_in_semi_automatic_mode() and cur_step <= old_step and not is_new_step):
# 		cur_step = read_cur_step_from_gui()
# 		sleep(STEP_SLEEP_INTERVAL)
# 	is_new_step = False

# def signal_handler(signum, frame):
# 	hr.callService('ResetPythonProgramStatus',[])
# 	rts.callService('StopPythonScript', [])
# 	sys.exit()


# if __name__ == "__main__":
# 	robot_handler = Robot()
# 	program_handler = Program(robot_handler)
# 	rts = Component(robot_handler, "RTS")
# 	hr = Component(robot_handler, "HR")
# 	signal.signal(signal.SIGINT, signal_handler)
# 	signal.signal(signal.SIGTERM, signal_handler)
# 	try:
# 		main(robot_handler)
# 	except Exception as e:
# 		print('Exception:',str(e.msg if hasattr(e,'msg') else e))
# 		hr.callService('ResetPythonProgramStatus',[])
# 		program_handler._Program__PS.socket_object.send_gui_message('Error ' + str(e.msg if hasattr(e,'msg') else e)) 
# 	finally:
# 		# setting tool parameter into robot handler
# 		robot_handler.set_tool(tool_name = 'NoTool',tool_params = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
# 		# program_handler.finish()
# 		rts.callService('StopPythonScript', [])
# 		signal_handler(None, None)

# This file has been generated by neura_program_generator version 0.0.1 on 2024-12-19 10:09:43.065282
# Program name in GUI: Program_002

from time import sleep
import signal
import sys
import threading

import socketio

from neurapy.state_flag import cmd
from neurapy.component import Component
from neura_apps.gui_program.program import Program
from neurapy.robot import Robot
from neurapy.commands.state.robot_status import RobotStatus
from neurapy.loop_counter import loopCount
from neurapy.utils import CmdIDManager
from neurapy.socket_client import _SocketClient, get_sio_client_singleton_instance

from move_camera.servo import ServoApp

# Global constants
STEP_SLEEP_INTERVAL = 0.01

# Global variables
cur_step: int = 0
is_new_step: bool = False


def main(robot_handler):
    # --------------------------  CREATING Robot & Program & RobotStatus OBJECTS  -----------------------
    program_handler = Program(robot_handler)
    robot_status = RobotStatus(robot_handler)
    iterator = loopCount()
    tool_objects = {}
    blackboard = {}

    robot_handler.notify_info("Starting execution of program 'Program_002'")

    sio_object: _SocketClient = register_sio_callbacks(program_handler)

    # Set initial value of dynamic id higher than the highest fixed cmd_id, so it does not intervene
    id_manager = CmdIDManager(3)

    # Initializing local tools for Program 'Program_002'
    tool_objects['NoTool'] = robot_handler.gripper(gripper_name='STANDARD_GRIPPER', tool_name='NoTool')
    # Setting tool 'NoTool' for Program 'Program_002'
    try:
        current_tool = 'NoTool'
        current_tool_params = [0] * 16  # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        robot_handler.set_tool(tool_name=current_tool, tool_params=current_tool_params)
    except Exception as e:
        program_handler._Program__PS.socket_object.send_gui_message(
            f'Error {current_tool} tool not set properly: {str(e)}', 'Error'
        )
        raise e

    ms_001 = ServoApp(
        robot_handler,
        servo_type='Static',
        program_name='Program_002',
        app_name='ms_001',
        cmd_id=2
    )

    # -------------------------------  INITIAL JOINT STATE & CARTESIAN POSE  ----------------------------
    previous_joint_angles = robot_status.getRobotStatus('jointAngles')
    previous_cartesian_poses = robot_handler.ik_fk(
        mode="fk",
        target_angle=previous_joint_angles,
        tool_params=current_tool_params
    )

    # -------------------------------  DEFINE TARGET POSE  ----------------------------
    # Define target position and orientation
    target_position = {
        "x": -0.553,  # Replace with your desired X coordinate (in millimeters or your unit of measurement)
        "y": -0.417,    # Replace with your desired Y coordinate
        "z": 0.234   # Replace with your desired Z coordinate
    }

    target_orientation = {
        "roll": -3.02,    # Replace with your desired Roll (in degrees or radians)
        "pitch": -0.06,  # Replace with your desired Pitch
        "yaw": 1.41      # Replace with your desired Yaw
    }

    # Combine position and orientation into a single pose
    target_cartesian_pose = {
        "position": target_position,
        "orientation": target_orientation
    }

    # Compute target joint angles using IK
    try:
        target_joint_angles = robot_handler.ik_fk(
            mode="ik",
            target_pose=target_cartesian_pose,
            tool_params=current_tool_params
        )
    except Exception as e:
        program_handler._Program__PS.socket_object.send_gui_message(
            f'Inverse Kinematics computation failed: {str(e)}', 'Error'
        )
        raise e

    # -------------------------------  SET MOTION DATA  ----------------------------
    motion_data = {
        "speed": 50.0,          # Adjust speed as needed
        "acceleration": 50.0,   # Adjust acceleration as needed
        "target_joint": [
            previous_joint_angles,  # Starting position (current joint angles)
            target_joint_angles     # Target position (computed joint angles)
        ]
    }

    # Planning movement to the target position
    program_handler.set_command(
        cmd.Joint,
        **motion_data,
        cmd_id=1,
        current_joint_angles=previous_joint_angles,
        reusable_id=0
    )
    program_handler.execute([1])

    # --------------------------------------  EXECUTING COMMANDS  ---------------------------------------
    # Executing ms_001
    block_until_next_step(robot_handler)
    ms_001.execute()
    sio_object.send_gui_message({'state': 'FINISHED'}, socket_name='StepByStep')


def register_sio_callbacks(program_handler: Program) -> _SocketClient:
    sio_handler = get_sio_client_singleton_instance()
    sio_register = sio_handler.get_sio_client_register_obj()
    sio_register.on("StepByStep", handle_sio_step_by_step)
    sio_obj_client = sio_handler.get_sio_client_obj()
    return sio_obj_client


def handle_sio_step_by_step(data: dict):
    global cur_step
    global is_new_step
    print(f"handling socket message on channel 'StepByStep' with data {data}")
    old_step = cur_step
    cur_step = int(data.get('id', -1))
    if old_step != cur_step:
        is_new_step = True


def read_cur_step_from_gui() -> int:
    global cur_step
    return cur_step


def block_until_next_step(robot: Robot):
    global cur_step
    global is_new_step
    old_step = cur_step
    while(robot.is_robot_in_semi_automatic_mode() and cur_step <= old_step and not is_new_step):
        cur_step = read_cur_step_from_gui()
        sleep(STEP_SLEEP_INTERVAL)
    is_new_step = False


def signal_handler(signum, frame):
    hr.callService('ResetPythonProgramStatus', [])
    rts.callService('StopPythonScript', [])
    sys.exit()


if __name__ == "__main__":
    robot_handler = Robot()
    program_handler = Program(robot_handler)
    rts = Component(robot_handler, "RTS")
    hr = Component(robot_handler, "HR")
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    try:
        main(robot_handler)
    except Exception as e:
        print('Exception:', str(e.msg if hasattr(e, 'msg') else e))
        hr.callService('ResetPythonProgramStatus', [])
        program_handler._Program__PS.socket_object.send_gui_message(
            'Error ' + str(e.msg if hasattr(e, 'msg') else e)
        )
    finally:
        # setting tool parameter into robot handler
        robot_handler.set_tool(tool_name='NoTool', tool_params=[0] * 16)
        # program_handler.finish()
        rts.callService('StopPythonScript', [])
        signal_handler(None, None)
